<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>dataanalyzer.plotter.plotter_main API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dataanalyzer.plotter.plotter_main</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Author: Malthe Asmus Marciniak Nielsen
import os
from typing import Any, Tuple, Union

import matplotlib as mpl
import matplotlib.pyplot as plt
import numpy as np
from matplotlib import gridspec, ticker
from matplotlib.axes import Axes
from matplotlib.figure import Figure

from dataanalyzer.fitter import Fitter
from dataanalyzer.plotter.plotter_decorators import matplotlib_decorator
from dataanalyzer.utilities import (
    Valueclass,
    convert_array_with_unit,
)


class Plotter:
    def __init__(
        self,
        subplots: Tuple[int, int] = (1, 1),
        default_settings: Union[dict, str, bool] = True,
        interactive: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;The Plotter class is a wrapper for matplotlib.pyplot. It is used to plot data in a consistent way.

        Args:
            subplots (tuple, optional): The shape of the subplots. Defaults to (1, 1).

        Raises:
            ValueError: If the default settings are not a valid type.
        &#34;&#34;&#34;

        # Enable interactive mode
        if interactive:
            mpl.use(&#34;Qt5Agg&#34;)

        self.kwargs = kwargs

        # Set default settings
        self.set_default_settings(default_settings)

        # Setup the figure and axes
        self._setup_fig_and_ax(subplots)

        self.metadata = &#34;&#34;

    def _setup_fig_and_ax(self, subplots: tuple) -&gt; None:
        &#34;&#34;&#34;Setup the figure and axes. If a figure is provided in the keyword arguments, 
        it will be used. Otherwise, a new figure will be created.

        Args:
            subplots (tuple): The shape of the subplots.
        &#34;&#34;&#34;
        # Get the figure from the keyword arguments if it exists
        self.fig: Figure = self.kwargs.pop(&#34;fig&#34;, None)
        # Set the number of columns to be one more than the number of subplots
        subplots_plus_col = (subplots[0], subplots[1] + 1)

        # If the figure doesn&#39;t exist, create it
        if self.fig is None:
            self.fig, axs = plt.subplots(*subplots_plus_col)
        else:
            # If the figure exists, clear it
            self.fig.clf()
            # Get the axes from the figure
            axs = self.fig.subplots(*subplots_plus_col)

        # Reshape the axes into a grid
        axs = np.array(axs).reshape(subplots_plus_col)
        # Set the axes
        self.axs: np.ndarray[Axes, Any] = axs[0:, :-1]
        # Set the axis for the annotations
        self.ax = self.axs[0, 0]

        # Set up the axis for the annotations
        self._setup_ax_anotate(ax_anotate=axs[0:, -1])

    def _setup_ax_anotate(self, ax_anotate: np.ndarray[Axes, Any]) -&gt; None:
        &#34;&#34;&#34;Setup the axis for the annotations. This function removes all axes from the figure and adds a new axis to the figure.

        Args:
            ax_anotate (np.ndarray[Axes, Any]): The axis to use for the annotations.
        &#34;&#34;&#34;
        # Get the grid spec of the first axis
        gs = ax_anotate[0].get_gridspec()

        # Remove all axes from the figure
        for ax in ax_anotate:
            ax.remove()

        # Add the new axis to the figure
        self.ax_anotate = self.fig.add_subplot(gs[0:, -1])

        # Set the axis to invisible
        self.ax_anotate.axis(&#34;off&#34;)

        # Set a flag to remove the axis on the next update
        self._remove_ax_anotate = True

    def set_default_settings(
        self, default_settings: Union[dict, str, bool] = True
    ) -&gt; None:
        &#34;&#34;&#34;Sets the default settings for the plotter. This function is a wrapper for matplotlib.pyplot.style.use

        Args:
            default_settings (Union[dict, str, bool], optional): The default settings to use. Defaults to True.
        &#34;&#34;&#34;
        # If the user wants to use the default settings, load the default settings
        # from the quantum_calibrator.mplstyle file
        if default_settings is True or default_settings == &#34;quantum_calibrator&#34;:
            dirname = os.path.dirname(__file__)
            plt.style.use(
                os.path.join(dirname, r&#34;plot_styles/quantum_calibrator.mplstyle&#34;)
            )

        # If the user wants to use the presentation settings, load the presentation
        # settings from the presentation.mplstyle file
        elif default_settings == &#34;presentation&#34;:
            dirname = os.path.dirname(__file__)
            plt.style.use(os.path.join(dirname, r&#34;plot_styles/presentation.mplstyle&#34;))

        # If the user wants to use no default settings, load the default matplotlib
        # settings
        elif default_settings is False:
            plt.style.use(&#34;default&#34;)

        # If the user passes a dictionary with settings, load these settings
        elif isinstance(default_settings, dict):
            plt.rcParams.update(default_settings)

        # If the user passes a string with a style, load this style
        elif isinstance(default_settings, str):
            plt.style.use(default_settings)

        # If the user passes anything else, raise an error
        else:
            raise ValueError(
                &#34;default_settings must be either a dict, a string or a boolean&#34;
            )

    def plot_fit(self, fit_obejct: Fitter, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;Plots a fit object. This function is a wrapper for matplotlib.pyplot.plot

        Args:
            fit_obejct (object): The fit object to plot.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        flip_axis = kwargs.pop(&#34;flip_axis&#34;, False)
        ls_start = kwargs.pop(&#34;linspace_start&#34;, None)
        ls_stop = kwargs.pop(&#34;linspace_stop&#34;, None)
        ls_steps = kwargs.pop(&#34;linspace_steps&#34;, 1000)

        if kwargs.pop(&#34;force_fit&#34;, False) or not fit_obejct._fitted:
            fit_obejct.do_fit(**kwargs)

        if kwargs.pop(&#34;plot_data&#34;, True):
            x, y = fit_obejct.x, fit_obejct.y

            if flip_axis:
                x, y = y, x

            self.scatter(x, y, ax=ax, label=&#34;Data&#34;)

        if kwargs.pop(&#34;plot_guess&#34;, True):
            x_guess, y_guess = fit_obejct.get_guess_array(ls_start, ls_stop, ls_steps)
            x_guess = Valueclass.fromfloat(x_guess, &#34;X guess&#34;)
            y_guess = Valueclass.fromfloat(y_guess, &#34;Y guess&#34;)

            if flip_axis:
                x_guess, y_guess = y_guess, x_guess

            self.plot(x_guess, y_guess, ax=ax, ls=&#34;--&#34;, color=&#34;grey&#34;, label=&#34;Guess&#34;)

        if kwargs.pop(&#34;plot_fit&#34;, True):
            x_fit, y_fit = fit_obejct.get_fit_array(ls_start, ls_stop, ls_steps)
            x_fit = Valueclass.fromfloat(x_fit, &#34;X fitted&#34;)
            y_fit = Valueclass.fromfloat(y_fit, &#34;Y fitted&#34;)

            if flip_axis:
                x_fit, y_fit = y_fit, x_fit

            self.plot(x_fit, y_fit, ax=ax, label=&#34;Fit&#34;)

        if kwargs.pop(&#34;plot_residuals&#34;, False):
            x_res = fit_obejct.x
            y_res = fit_obejct.get_residuals()

            if flip_axis:
                x_res, y_res = y_res, x_res
                self.add_yresiuals(x_res, y_res, ax=ax)
            else:
                self.add_xresiuals(x_res, y_res, ax=ax)

        if kwargs.pop(&#34;plot_metadata&#34;, True):
            self.add_metadata(fit_obejct._report_string, ax=ax)

    @matplotlib_decorator
    def plot(
        self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs,
    ):
        &#34;&#34;&#34;plotting function for 1d data. This function is a wrapper for matplotlib.pyplot.plot

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is conv erted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;

        try:
            self.ax.plot(x.value, y.value, **kwargs)
        except ValueError:
            self.ax.plot(x.value, y.value.T, **kwargs)
            print(&#34;Warning: x and y have different shapes. Transposing y.&#34;)

    @matplotlib_decorator
    def scatter(self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;plotting function for 1d data. This function is a wrapper for matplotlib.pyplot.scatter

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        # kwargs.setdefault(&#34;marker&#34;, &#34;x&#34;)
        kwargs.setdefault(&#34;s&#34;, 15)

        try:
            self.ax.scatter(x.value, y.value, **kwargs)
        except ValueError:
            try:
                [
                    self.ax.scatter(x.value, y.value[i], **kwargs)
                    for i in range(y.value.shape[0])
                ]
            except ValueError:
                [
                    self.ax.scatter(x.value, y.value[:, i], **kwargs)
                    for i in range(y.value.shape[1])
                ]
                print(&#34;Warning: x and y have different shapes. Transposing y.&#34;)

    @matplotlib_decorator
    def bar(self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;plotting function for 1d data. This function is a wrapper for matplotlib.pyplot.bar

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        kwargs.setdefault(&#34;width&#34;, 0.5)

        try:
            self.ax.bar(x.value, y.value, **kwargs)
        except ValueError:
            self.ax.bar(x.value, y.value.T, **kwargs)
            print(&#34;Warning: x and y have different shapes. Transposing y.&#34;)

    @matplotlib_decorator
    def errorbar(self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;plotting function for 1d data. This function is a wrapper for matplotlib.pyplot.errorbar

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        kwargs.setdefault(&#34;fmt&#34;, &#34;.&#34;)
        kwargs.setdefault(&#34;elinewidth&#34;, 2)
        kwargs.setdefault(&#34;capsize&#34;, 3)

        yerr = kwargs.pop(&#34;yerr&#34;, y.error)
        xerr = kwargs.pop(&#34;xerr&#34;, x.error)

        if isinstance(yerr, Valueclass):
            yerr = yerr.value
        if isinstance(xerr, Valueclass):
            xerr = xerr.value

        try:
            self.ax.errorbar(x=x.value, y=y.value, yerr=yerr, xerr=xerr, **kwargs)
        except ValueError:
            self.ax.errorbar(x=x.value, y=y.value.T, yerr=yerr.T, xerr=xerr, **kwargs)
            print(&#34;Warning: x and y have different shapes. Transposing y.&#34;)

    @matplotlib_decorator
    def _2d_genereal_plot(
        self,
        plot_type: str,
        x: Valueclass,
        y: Valueclass,
        z: Valueclass,
        ax: tuple = (),
        add_colorbar: bool = True,
        **kwargs,
    ):
        &#34;&#34;&#34;general plotting function for 2d data. This function is a wrapper for matplotlib.pyplot

        Args:
            plot_type (str): The type of plot to use. This is the name of the function in matplotlib.pyplot. e.g. &#34;contourf&#34;. Options: &#34;contourf&#34;, &#34;contour&#34;, &#34;pcolormesh&#34;, &#34;imshow&#34;.
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().

        Raises:
            ValueError: If plot_type is not a valid option.
        &#34;&#34;&#34;
        keep_colorbar = kwargs.pop(&#34;keep_colorbar&#34;, False)
        kwargs.setdefault(&#34;cmap&#34;, &#34;RdBu&#34;)
        kwargs.setdefault(&#34;vmin&#34;, np.min(z.value))
        kwargs.setdefault(&#34;vmax&#34;, np.max(z.value))

        if plot_type == &#34;pcolormesh&#34;:
            c = self.ax.pcolormesh(x.value, y.value, z.value, **kwargs)

        elif plot_type == &#34;contour&#34;:
            c = self.ax.contour(x.value, y.value, z.value, **kwargs)

        elif plot_type == &#34;contourf&#34;:
            c = self.ax.contourf(x.value, y.value, z.value, **kwargs)

        elif plot_type == &#34;tricontour&#34;:
            c = self.ax.tricontour(x.value, y.value, z.value, **kwargs)

        elif plot_type == &#34;tricontourf&#34;:
            c = self.ax.tricontourf(x.value, y.value, z.value, **kwargs)

        elif plot_type == &#34;tripcolor&#34;:
            c = self.ax.tripcolor(x.value, y.value, z.value, **kwargs)

        else:
            raise ValueError(f&#34;plot_type {plot_type} not recognized&#34;)

        self.ax.axis([x.value.min(), x.value.max(), y.value.min(), y.value.max()])  # type: ignore

        if add_colorbar:
            self._add_colorbar(c, z, keep_colorbar)

    def _add_colorbar(self, c, z, keep_colorbar):
        if hasattr(self.ax, &#34;colorbar&#34;) and not keep_colorbar:
            for colorbar in self.ax.colorbar:
                colorbar.remove()

        label = f&#34;{z.name} [{z.unit}]&#34; if z.unit else f&#34;{z.name}&#34;
        colorbar = self.fig.colorbar(c, ax=self.ax, label=label)

        for ax in self.axs.flatten():
            if ax == self.ax:
                if not hasattr(ax, &#34;colorbar&#34;):
                    ax.colorbar = [colorbar]
                else:
                    ax.colorbar.append(colorbar)

    def pcolormesh(
        self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.pcolormesh

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;pcolormesh&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)

    def heatmap(
        self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.pcolormesh

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;pcolormesh&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)

    def contour(
        self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.contour

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;contour&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)

    def contourf(
        self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.contourf

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;contourf&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)

    def tricontour(
        self, x: Valueclass, y: Valueclass, z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tricontour

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;tricontour&#34;, x=x, y=y, z=z, ax=ax, **kwargs)

    def tricontourf(
        self, x: Valueclass, y: Valueclass, z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tricontourf

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;tricontourf&#34;, x=x, y=y, z=z, ax=ax, **kwargs)

    def tripcolor(
        self, x: Valueclass, y: Valueclass, z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tripcolor

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;tripcolor&#34;, x=x, y=y, z=z, ax=ax, **kwargs)

    def axhline(
        self,
        y: Union[Valueclass, tuple, list, float, np.ndarray],
        xmin: float = 0,
        xmax: float = 1,
        linestyle: str = &#34;--&#34;,
        ax: tuple = (),
        **kwargs,
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axhline

        Args:
            y (float): y value to plot.
            min (float): minimum x value to plot.
            max (float): maximum x value to plot.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        if ax:
            self.ax = self.axs[ax]

        kwargs |= {&#34;xmin&#34;: xmin, &#34;xmax&#34;: xmax, &#34;linestyle&#34;: linestyle}

        if isinstance(y, Valueclass):
            self.ax.axhline(y=y.value, **kwargs)
        elif isinstance(y, (tuple, list)):
            for y_ in y:
                self.ax.axhline(y=y_, **kwargs)
        else:
            self.ax.axhline(y=y, **kwargs)

        self._plot_legends()

    def axvline(
        self,
        x: Union[Valueclass, tuple, list, float, np.ndarray],
        ymin: float = 0,
        ymax: float = 1,
        linestyle: str = &#34;--&#34;,
        ax: tuple = (),
        **kwargs,
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axvline

        Args:
            x (float): x value to plot.
            min (float): minimum y value to plot.
            max (float): maximum y value to plot.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        if ax:
            self.ax = self.axs[ax]

        kwargs |= {&#34;ymin&#34;: ymin, &#34;ymax&#34;: ymax, &#34;linestyle&#34;: linestyle}

        if isinstance(x, Valueclass):
            self.ax.axvline(x=x.value, **kwargs)
        elif isinstance(x, (tuple, list)):
            for x_ in x:
                self.ax.axvline(x=x_, **kwargs)
        else:
            self.ax.axvline(x=x, **kwargs)

        self._plot_legends()

    @matplotlib_decorator
    def add_yresiuals(self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axvline

        Args:
            x (float): x value to plot.
            min (float): minimum y value to plot.
            max (float): maximum y value to plot.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        # kwargs.setdefault(&#34;marker&#34;, &#34;x&#34;)
        kwargs.setdefault(&#34;s&#34;, 15)

        ax_shape = np.shape(self.axs)
        axarg = np.where(self.axs.flatten() == self.ax)[0][0]

        gs = gridspec.GridSpec(
            ax_shape[0],
            2 * ax_shape[1] + 2,
            width_ratios=[4, 1] * (ax_shape[1] + 1),
            wspace=0.00,
        )

        self.ax.set_subplotspec(gs[axarg])
        self.yres = self.fig.add_subplot(gs[axarg + 1])

        self.yres.scatter(x.value, y.value, **kwargs)
        self.yres.axvline(x=0, linestyle=&#34;:&#34;, color=&#34;red&#34;)

        self.yres.sharey(self.ax)
        self.yres.label_outer()  # type: ignore

        xlabel = kwargs.pop(
            &#34;xlabel&#34;, f&#34;Residuals [{x.unit}]&#34; if x.unit else &#34;Residuals&#34;
        )
        self.yres.set_xlabel(xlabel)

    @matplotlib_decorator
    def add_xresiuals(self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axvline

        Args:
            x (float): x value to plot.
            min (float): minimum y value to plot.
            max (float): maximum y value to plot.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        # kwargs.setdefault(&#34;marker&#34;, &#34;x&#34;)
        kwargs.setdefault(&#34;s&#34;, 15)

        ax_shape = np.shape(self.axs)
        axarg = np.where(self.axs.flatten() == self.ax)[0][0]

        gs = gridspec.GridSpec(
            2 * ax_shape[0],
            ax_shape[1] + 1,
            height_ratios=[4, 1] * (ax_shape[0]),
            hspace=0.00,
        )

        self.ax.set_subplotspec(gs[axarg])
        self.xres = self.fig.add_subplot(gs[1 + ax_shape[0]])

        self.xres.scatter(x.value, y.value, **kwargs)
        self.xres.axhline(y=0, linestyle=&#34;:&#34;, color=&#34;red&#34;)

        if self.ax._sharex is None or self.xres is self.ax._sharex:
            self.ax.sharex(self.xres)
            self.xres.set_xlabel(self.ax.get_xlabel())
            self.ax.label_outer()  # type: ignore

            ylabel = kwargs.pop(
                &#34;ylabel&#34;, f&#34;Residuals [{y.unit}]&#34; if y.unit else &#34;Residuals&#34;
            )
            self.xres.set_ylabel(ylabel)

    def add_metadata(
        self,
        *metadata: Union[
            str, Valueclass, list[Valueclass], tuple[Valueclass], dict[str, Valueclass]
        ],
        ax: tuple = (),
        overwrite: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;Adds metadata to the plot. This is done by adding a text box to the plot.

        Args:
            metadata (dict): The metadata to add to the plot. This is a dictionary with the keys as the metadata name and the values as the metadata value.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
            overwrite (bool, optional): If True, the metadata is overwritten. If False, the metadata is added to the existing metadata. Defaults to False.
        &#34;&#34;&#34;
        if ax:
            self.ax = self.axs[ax]

        default_kwargs = {
            &#34;x&#34;: 0.05,
            &#34;y&#34;: 0.95,
            &#34;va&#34;: &#34;top&#34;,
            &#34;ha&#34;: &#34;left&#34;,
            &#34;transform&#34;: self.ax_anotate.transAxes,
            &#34;fontdict&#34;: {&#34;family&#34;: &#34;monospace&#34;},
        }
        kwargs = default_kwargs | kwargs
        algin = kwargs.pop(&#34;algin&#34;, True)

        kwargs_metadata = {
            k.removeprefix(&#34;tostr_&#34;): kwargs.pop(k)
            for k in list(kwargs)
            if k.startswith(&#34;tostr_&#34;)
        }
        metadata_str = self._convert_metadata_to_str(
            *metadata, algin=algin, **kwargs_metadata
        )
        self.metadata = metadata_str if overwrite else f&#34;{self.metadata}{metadata_str}&#34;

        self.ax_anotate.texts.clear()
        self.ax_anotate.text(s=self.metadata, **kwargs)
        self._remove_ax_anotate = False

    def _convert_metadata_to_str(
        self,
        *metadata: Union[
            str, Valueclass, list[Valueclass], tuple[Valueclass], dict[str, Valueclass]
        ],
        algin: bool = True,
        add_parameter_header: bool = True,
        **kwargs,
    ) -&gt; str:
        name_width = kwargs.pop(&#34;tostr_name_width&#34;, 40)
        size_width = kwargs.pop(&#34;tostr_size_width&#34;, 7)

        # parameter_header = f&#34;{Mesuerment parameters : &lt;{name_width}}&#34; TODO: add parameter header
        # {&#34;N points&#34; : &lt;{size_width}}Values&#34;

        metadata_str = &#34;&#34;
        for param in metadata:
            if isinstance(param, str):
                metadata_str += f&#34;{param}\n&#34;

            elif isinstance(param, Valueclass):
                metadata_str += f&#34;{param.tostr(algin=algin, name_width=name_width, size_width=size_width, **kwargs)}\n&#34;

            elif isinstance(param, (list, tuple)):
                for par in param:
                    metadata_str += self._convert_metadata_to_str(par)

            elif isinstance(param, dict):
                for par in param.values():
                    metadata_str += self._convert_metadata_to_str(par)

            else:
                raise TypeError(
                    f&#34;metadata must be of type str, Valueclass, list[Value], tuple[Value], or dict[str, Value], not {type(param)}&#34;
                )

        return metadata_str

    def clear_metadata(self):
        self.metadata = &#34;&#34;
        self.ax_anotate.texts.clear()

    def _get_default_transform(self):
        axarg = np.where(self.axs == self.ax)[0][0]
        right_axs = self.axs[axarg, np.size(self.axs, axis=1) - 1]

        return (
            right_axs.colorbar.ax.transAxes
            if hasattr(right_axs, &#34;colorbar&#34;)
            else self.ax.transAxes
        )

    def _label_with_unit_prefix(self, label: str, unit_prefix: str):
        return (
            label.replace(&#34;[&#34;, f&#34;[{unit_prefix}&#34;)
            if &#34;[&#34; in label and &#34;]&#34; in label
            else f&#34;{label} [{unit_prefix}]&#34;
            if unit_prefix
            else label
        )

    def _rescale_axes(self):
        for ax in self.axs.flatten():
            self._get_set_ticks(&#34;x&#34;)(self, ax)
            self._get_set_ticks(&#34;y&#34;)(self, ax)

            if hasattr(ax, &#34;colorbar&#34;):
                for colorbar in ax.colorbar:
                    self._get_set_ticks(&#34;y&#34;)(self, colorbar)
                    self._get_set_ticks(&#34;x&#34;)(self, colorbar)

        if hasattr(self, &#34;yres&#34;):
            self._get_set_ticks(&#34;x&#34;)(self, self.yres)

        if hasattr(self, &#34;xres&#34;):
            self._get_set_ticks(&#34;x&#34;)(self, self.xres)
            self._get_set_ticks(&#34;y&#34;)(self, self.xres)

    def _set_ticks(self, axis, ticks):
        _, unit_prefix, scale = convert_array_with_unit(ticks)
        ticks = ticker.FuncFormatter(lambda v, pos: &#34;{0:g}&#34;.format(v * scale))
        axis.set_major_formatter(ticks)
        return unit_prefix

    def _get_set_ticks(self, axis: str = &#34;x&#34;):
        if axis not in [&#34;x&#34;, &#34;y&#34;]:
            raise ValueError(f&#34;Unknown axis: {axis}&#34;)

        orig_label = f&#34;original_{axis}label&#34;
        get_ticks = f&#34;get_{axis}ticks&#34;
        get_label = f&#34;get_{axis}label&#34;

        def _set_ticks(self, ax):
            if not hasattr(ax, get_ticks):
                ax = ax.ax

            original_label = _get_original_label(ax)

            if any(x not in original_label for x in [&#34;[&#34;, &#34;]&#34;]):
                return

            ticks = getattr(ax, get_ticks)()
            unit_prefix = self._set_ticks(getattr(ax, f&#34;{axis}axis&#34;), ticks)

            updated_label = self._label_with_unit_prefix(original_label, unit_prefix)

            if axis == &#34;x&#34;:
                ax.set_xlabel(updated_label)
            else:
                ax.set_ylabel(updated_label)

        def _get_original_label(ax):
            if not hasattr(ax, orig_label):
                setattr(ax, orig_label, getattr(ax, get_label)())

            original_label = getattr(ax, orig_label)
            return original_label

        return _set_ticks

    def _plot_legends(self):
        &#34;&#34;&#34;Adds legends to the plot if the user has specified them.&#34;&#34;&#34;
        [
            ax.legend()
            for ax in self.axs.flatten()
            if ax.get_legend_handles_labels() != ([], [])
        ]

    def show(self, return_fig: bool = False):
        &#34;&#34;&#34;Shows the plot. This function is a wrapper for matplotlib.pyplot.show

        Returns:
            fig: The figure object
        &#34;&#34;&#34;
        plt.figure(self.fig)

        if self._remove_ax_anotate:
            self._remove_ax_anotate = False
            self.ax_anotate.remove()

        self._rescale_axes()
        plt.tight_layout()

        if not return_fig:
            return plt.show()

        for fig_num in plt.get_fignums():
            if self.fig.number != fig_num:  # type: ignore
                plt.close(fig_num)

        plt.pause(0.001)
        return self.fig

    def save(self, path: str, **kwargs):
        &#34;&#34;&#34;Saves the plot. This function is a wrapper for matplotlib.pyplot.savefig

        Args:
            path (str): The path to save the plot to.
        &#34;&#34;&#34;
        plt.savefig(path, **kwargs)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dataanalyzer.plotter.plotter_main.Plotter"><code class="flex name class">
<span>class <span class="ident">Plotter</span></span>
<span>(</span><span>subplots: Tuple[int, int] = (1, 1), default_settings: Union[dict, str, bool] = True, interactive: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>The Plotter class is a wrapper for matplotlib.pyplot. It is used to plot data in a consistent way.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>subplots</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The shape of the subplots. Defaults to (1, 1).</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>ValueError</code></dt>
<dd>If the default settings are not a valid type.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Plotter:
    def __init__(
        self,
        subplots: Tuple[int, int] = (1, 1),
        default_settings: Union[dict, str, bool] = True,
        interactive: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;The Plotter class is a wrapper for matplotlib.pyplot. It is used to plot data in a consistent way.

        Args:
            subplots (tuple, optional): The shape of the subplots. Defaults to (1, 1).

        Raises:
            ValueError: If the default settings are not a valid type.
        &#34;&#34;&#34;

        # Enable interactive mode
        if interactive:
            mpl.use(&#34;Qt5Agg&#34;)

        self.kwargs = kwargs

        # Set default settings
        self.set_default_settings(default_settings)

        # Setup the figure and axes
        self._setup_fig_and_ax(subplots)

        self.metadata = &#34;&#34;

    def _setup_fig_and_ax(self, subplots: tuple) -&gt; None:
        &#34;&#34;&#34;Setup the figure and axes. If a figure is provided in the keyword arguments, 
        it will be used. Otherwise, a new figure will be created.

        Args:
            subplots (tuple): The shape of the subplots.
        &#34;&#34;&#34;
        # Get the figure from the keyword arguments if it exists
        self.fig: Figure = self.kwargs.pop(&#34;fig&#34;, None)
        # Set the number of columns to be one more than the number of subplots
        subplots_plus_col = (subplots[0], subplots[1] + 1)

        # If the figure doesn&#39;t exist, create it
        if self.fig is None:
            self.fig, axs = plt.subplots(*subplots_plus_col)
        else:
            # If the figure exists, clear it
            self.fig.clf()
            # Get the axes from the figure
            axs = self.fig.subplots(*subplots_plus_col)

        # Reshape the axes into a grid
        axs = np.array(axs).reshape(subplots_plus_col)
        # Set the axes
        self.axs: np.ndarray[Axes, Any] = axs[0:, :-1]
        # Set the axis for the annotations
        self.ax = self.axs[0, 0]

        # Set up the axis for the annotations
        self._setup_ax_anotate(ax_anotate=axs[0:, -1])

    def _setup_ax_anotate(self, ax_anotate: np.ndarray[Axes, Any]) -&gt; None:
        &#34;&#34;&#34;Setup the axis for the annotations. This function removes all axes from the figure and adds a new axis to the figure.

        Args:
            ax_anotate (np.ndarray[Axes, Any]): The axis to use for the annotations.
        &#34;&#34;&#34;
        # Get the grid spec of the first axis
        gs = ax_anotate[0].get_gridspec()

        # Remove all axes from the figure
        for ax in ax_anotate:
            ax.remove()

        # Add the new axis to the figure
        self.ax_anotate = self.fig.add_subplot(gs[0:, -1])

        # Set the axis to invisible
        self.ax_anotate.axis(&#34;off&#34;)

        # Set a flag to remove the axis on the next update
        self._remove_ax_anotate = True

    def set_default_settings(
        self, default_settings: Union[dict, str, bool] = True
    ) -&gt; None:
        &#34;&#34;&#34;Sets the default settings for the plotter. This function is a wrapper for matplotlib.pyplot.style.use

        Args:
            default_settings (Union[dict, str, bool], optional): The default settings to use. Defaults to True.
        &#34;&#34;&#34;
        # If the user wants to use the default settings, load the default settings
        # from the quantum_calibrator.mplstyle file
        if default_settings is True or default_settings == &#34;quantum_calibrator&#34;:
            dirname = os.path.dirname(__file__)
            plt.style.use(
                os.path.join(dirname, r&#34;plot_styles/quantum_calibrator.mplstyle&#34;)
            )

        # If the user wants to use the presentation settings, load the presentation
        # settings from the presentation.mplstyle file
        elif default_settings == &#34;presentation&#34;:
            dirname = os.path.dirname(__file__)
            plt.style.use(os.path.join(dirname, r&#34;plot_styles/presentation.mplstyle&#34;))

        # If the user wants to use no default settings, load the default matplotlib
        # settings
        elif default_settings is False:
            plt.style.use(&#34;default&#34;)

        # If the user passes a dictionary with settings, load these settings
        elif isinstance(default_settings, dict):
            plt.rcParams.update(default_settings)

        # If the user passes a string with a style, load this style
        elif isinstance(default_settings, str):
            plt.style.use(default_settings)

        # If the user passes anything else, raise an error
        else:
            raise ValueError(
                &#34;default_settings must be either a dict, a string or a boolean&#34;
            )

    def plot_fit(self, fit_obejct: Fitter, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;Plots a fit object. This function is a wrapper for matplotlib.pyplot.plot

        Args:
            fit_obejct (object): The fit object to plot.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        flip_axis = kwargs.pop(&#34;flip_axis&#34;, False)
        ls_start = kwargs.pop(&#34;linspace_start&#34;, None)
        ls_stop = kwargs.pop(&#34;linspace_stop&#34;, None)
        ls_steps = kwargs.pop(&#34;linspace_steps&#34;, 1000)

        if kwargs.pop(&#34;force_fit&#34;, False) or not fit_obejct._fitted:
            fit_obejct.do_fit(**kwargs)

        if kwargs.pop(&#34;plot_data&#34;, True):
            x, y = fit_obejct.x, fit_obejct.y

            if flip_axis:
                x, y = y, x

            self.scatter(x, y, ax=ax, label=&#34;Data&#34;)

        if kwargs.pop(&#34;plot_guess&#34;, True):
            x_guess, y_guess = fit_obejct.get_guess_array(ls_start, ls_stop, ls_steps)
            x_guess = Valueclass.fromfloat(x_guess, &#34;X guess&#34;)
            y_guess = Valueclass.fromfloat(y_guess, &#34;Y guess&#34;)

            if flip_axis:
                x_guess, y_guess = y_guess, x_guess

            self.plot(x_guess, y_guess, ax=ax, ls=&#34;--&#34;, color=&#34;grey&#34;, label=&#34;Guess&#34;)

        if kwargs.pop(&#34;plot_fit&#34;, True):
            x_fit, y_fit = fit_obejct.get_fit_array(ls_start, ls_stop, ls_steps)
            x_fit = Valueclass.fromfloat(x_fit, &#34;X fitted&#34;)
            y_fit = Valueclass.fromfloat(y_fit, &#34;Y fitted&#34;)

            if flip_axis:
                x_fit, y_fit = y_fit, x_fit

            self.plot(x_fit, y_fit, ax=ax, label=&#34;Fit&#34;)

        if kwargs.pop(&#34;plot_residuals&#34;, False):
            x_res = fit_obejct.x
            y_res = fit_obejct.get_residuals()

            if flip_axis:
                x_res, y_res = y_res, x_res
                self.add_yresiuals(x_res, y_res, ax=ax)
            else:
                self.add_xresiuals(x_res, y_res, ax=ax)

        if kwargs.pop(&#34;plot_metadata&#34;, True):
            self.add_metadata(fit_obejct._report_string, ax=ax)

    @matplotlib_decorator
    def plot(
        self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs,
    ):
        &#34;&#34;&#34;plotting function for 1d data. This function is a wrapper for matplotlib.pyplot.plot

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is conv erted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;

        try:
            self.ax.plot(x.value, y.value, **kwargs)
        except ValueError:
            self.ax.plot(x.value, y.value.T, **kwargs)
            print(&#34;Warning: x and y have different shapes. Transposing y.&#34;)

    @matplotlib_decorator
    def scatter(self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;plotting function for 1d data. This function is a wrapper for matplotlib.pyplot.scatter

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        # kwargs.setdefault(&#34;marker&#34;, &#34;x&#34;)
        kwargs.setdefault(&#34;s&#34;, 15)

        try:
            self.ax.scatter(x.value, y.value, **kwargs)
        except ValueError:
            try:
                [
                    self.ax.scatter(x.value, y.value[i], **kwargs)
                    for i in range(y.value.shape[0])
                ]
            except ValueError:
                [
                    self.ax.scatter(x.value, y.value[:, i], **kwargs)
                    for i in range(y.value.shape[1])
                ]
                print(&#34;Warning: x and y have different shapes. Transposing y.&#34;)

    @matplotlib_decorator
    def bar(self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;plotting function for 1d data. This function is a wrapper for matplotlib.pyplot.bar

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        kwargs.setdefault(&#34;width&#34;, 0.5)

        try:
            self.ax.bar(x.value, y.value, **kwargs)
        except ValueError:
            self.ax.bar(x.value, y.value.T, **kwargs)
            print(&#34;Warning: x and y have different shapes. Transposing y.&#34;)

    @matplotlib_decorator
    def errorbar(self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;plotting function for 1d data. This function is a wrapper for matplotlib.pyplot.errorbar

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        kwargs.setdefault(&#34;fmt&#34;, &#34;.&#34;)
        kwargs.setdefault(&#34;elinewidth&#34;, 2)
        kwargs.setdefault(&#34;capsize&#34;, 3)

        yerr = kwargs.pop(&#34;yerr&#34;, y.error)
        xerr = kwargs.pop(&#34;xerr&#34;, x.error)

        if isinstance(yerr, Valueclass):
            yerr = yerr.value
        if isinstance(xerr, Valueclass):
            xerr = xerr.value

        try:
            self.ax.errorbar(x=x.value, y=y.value, yerr=yerr, xerr=xerr, **kwargs)
        except ValueError:
            self.ax.errorbar(x=x.value, y=y.value.T, yerr=yerr.T, xerr=xerr, **kwargs)
            print(&#34;Warning: x and y have different shapes. Transposing y.&#34;)

    @matplotlib_decorator
    def _2d_genereal_plot(
        self,
        plot_type: str,
        x: Valueclass,
        y: Valueclass,
        z: Valueclass,
        ax: tuple = (),
        add_colorbar: bool = True,
        **kwargs,
    ):
        &#34;&#34;&#34;general plotting function for 2d data. This function is a wrapper for matplotlib.pyplot

        Args:
            plot_type (str): The type of plot to use. This is the name of the function in matplotlib.pyplot. e.g. &#34;contourf&#34;. Options: &#34;contourf&#34;, &#34;contour&#34;, &#34;pcolormesh&#34;, &#34;imshow&#34;.
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().

        Raises:
            ValueError: If plot_type is not a valid option.
        &#34;&#34;&#34;
        keep_colorbar = kwargs.pop(&#34;keep_colorbar&#34;, False)
        kwargs.setdefault(&#34;cmap&#34;, &#34;RdBu&#34;)
        kwargs.setdefault(&#34;vmin&#34;, np.min(z.value))
        kwargs.setdefault(&#34;vmax&#34;, np.max(z.value))

        if plot_type == &#34;pcolormesh&#34;:
            c = self.ax.pcolormesh(x.value, y.value, z.value, **kwargs)

        elif plot_type == &#34;contour&#34;:
            c = self.ax.contour(x.value, y.value, z.value, **kwargs)

        elif plot_type == &#34;contourf&#34;:
            c = self.ax.contourf(x.value, y.value, z.value, **kwargs)

        elif plot_type == &#34;tricontour&#34;:
            c = self.ax.tricontour(x.value, y.value, z.value, **kwargs)

        elif plot_type == &#34;tricontourf&#34;:
            c = self.ax.tricontourf(x.value, y.value, z.value, **kwargs)

        elif plot_type == &#34;tripcolor&#34;:
            c = self.ax.tripcolor(x.value, y.value, z.value, **kwargs)

        else:
            raise ValueError(f&#34;plot_type {plot_type} not recognized&#34;)

        self.ax.axis([x.value.min(), x.value.max(), y.value.min(), y.value.max()])  # type: ignore

        if add_colorbar:
            self._add_colorbar(c, z, keep_colorbar)

    def _add_colorbar(self, c, z, keep_colorbar):
        if hasattr(self.ax, &#34;colorbar&#34;) and not keep_colorbar:
            for colorbar in self.ax.colorbar:
                colorbar.remove()

        label = f&#34;{z.name} [{z.unit}]&#34; if z.unit else f&#34;{z.name}&#34;
        colorbar = self.fig.colorbar(c, ax=self.ax, label=label)

        for ax in self.axs.flatten():
            if ax == self.ax:
                if not hasattr(ax, &#34;colorbar&#34;):
                    ax.colorbar = [colorbar]
                else:
                    ax.colorbar.append(colorbar)

    def pcolormesh(
        self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.pcolormesh

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;pcolormesh&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)

    def heatmap(
        self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.pcolormesh

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;pcolormesh&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)

    def contour(
        self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.contour

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;contour&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)

    def contourf(
        self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.contourf

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;contourf&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)

    def tricontour(
        self, x: Valueclass, y: Valueclass, z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tricontour

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;tricontour&#34;, x=x, y=y, z=z, ax=ax, **kwargs)

    def tricontourf(
        self, x: Valueclass, y: Valueclass, z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tricontourf

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;tricontourf&#34;, x=x, y=y, z=z, ax=ax, **kwargs)

    def tripcolor(
        self, x: Valueclass, y: Valueclass, z: Valueclass, ax: tuple = (), **kwargs
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tripcolor

        Args:
            x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
            y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
            Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        self._2d_genereal_plot(plot_type=&#34;tripcolor&#34;, x=x, y=y, z=z, ax=ax, **kwargs)

    def axhline(
        self,
        y: Union[Valueclass, tuple, list, float, np.ndarray],
        xmin: float = 0,
        xmax: float = 1,
        linestyle: str = &#34;--&#34;,
        ax: tuple = (),
        **kwargs,
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axhline

        Args:
            y (float): y value to plot.
            min (float): minimum x value to plot.
            max (float): maximum x value to plot.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        if ax:
            self.ax = self.axs[ax]

        kwargs |= {&#34;xmin&#34;: xmin, &#34;xmax&#34;: xmax, &#34;linestyle&#34;: linestyle}

        if isinstance(y, Valueclass):
            self.ax.axhline(y=y.value, **kwargs)
        elif isinstance(y, (tuple, list)):
            for y_ in y:
                self.ax.axhline(y=y_, **kwargs)
        else:
            self.ax.axhline(y=y, **kwargs)

        self._plot_legends()

    def axvline(
        self,
        x: Union[Valueclass, tuple, list, float, np.ndarray],
        ymin: float = 0,
        ymax: float = 1,
        linestyle: str = &#34;--&#34;,
        ax: tuple = (),
        **kwargs,
    ):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axvline

        Args:
            x (float): x value to plot.
            min (float): minimum y value to plot.
            max (float): maximum y value to plot.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        if ax:
            self.ax = self.axs[ax]

        kwargs |= {&#34;ymin&#34;: ymin, &#34;ymax&#34;: ymax, &#34;linestyle&#34;: linestyle}

        if isinstance(x, Valueclass):
            self.ax.axvline(x=x.value, **kwargs)
        elif isinstance(x, (tuple, list)):
            for x_ in x:
                self.ax.axvline(x=x_, **kwargs)
        else:
            self.ax.axvline(x=x, **kwargs)

        self._plot_legends()

    @matplotlib_decorator
    def add_yresiuals(self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axvline

        Args:
            x (float): x value to plot.
            min (float): minimum y value to plot.
            max (float): maximum y value to plot.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        # kwargs.setdefault(&#34;marker&#34;, &#34;x&#34;)
        kwargs.setdefault(&#34;s&#34;, 15)

        ax_shape = np.shape(self.axs)
        axarg = np.where(self.axs.flatten() == self.ax)[0][0]

        gs = gridspec.GridSpec(
            ax_shape[0],
            2 * ax_shape[1] + 2,
            width_ratios=[4, 1] * (ax_shape[1] + 1),
            wspace=0.00,
        )

        self.ax.set_subplotspec(gs[axarg])
        self.yres = self.fig.add_subplot(gs[axarg + 1])

        self.yres.scatter(x.value, y.value, **kwargs)
        self.yres.axvline(x=0, linestyle=&#34;:&#34;, color=&#34;red&#34;)

        self.yres.sharey(self.ax)
        self.yres.label_outer()  # type: ignore

        xlabel = kwargs.pop(
            &#34;xlabel&#34;, f&#34;Residuals [{x.unit}]&#34; if x.unit else &#34;Residuals&#34;
        )
        self.yres.set_xlabel(xlabel)

    @matplotlib_decorator
    def add_xresiuals(self, x: Valueclass, y: Valueclass, ax: tuple = (), **kwargs):
        &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axvline

        Args:
            x (float): x value to plot.
            min (float): minimum y value to plot.
            max (float): maximum y value to plot.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        &#34;&#34;&#34;
        # kwargs.setdefault(&#34;marker&#34;, &#34;x&#34;)
        kwargs.setdefault(&#34;s&#34;, 15)

        ax_shape = np.shape(self.axs)
        axarg = np.where(self.axs.flatten() == self.ax)[0][0]

        gs = gridspec.GridSpec(
            2 * ax_shape[0],
            ax_shape[1] + 1,
            height_ratios=[4, 1] * (ax_shape[0]),
            hspace=0.00,
        )

        self.ax.set_subplotspec(gs[axarg])
        self.xres = self.fig.add_subplot(gs[1 + ax_shape[0]])

        self.xres.scatter(x.value, y.value, **kwargs)
        self.xres.axhline(y=0, linestyle=&#34;:&#34;, color=&#34;red&#34;)

        if self.ax._sharex is None or self.xres is self.ax._sharex:
            self.ax.sharex(self.xres)
            self.xres.set_xlabel(self.ax.get_xlabel())
            self.ax.label_outer()  # type: ignore

            ylabel = kwargs.pop(
                &#34;ylabel&#34;, f&#34;Residuals [{y.unit}]&#34; if y.unit else &#34;Residuals&#34;
            )
            self.xres.set_ylabel(ylabel)

    def add_metadata(
        self,
        *metadata: Union[
            str, Valueclass, list[Valueclass], tuple[Valueclass], dict[str, Valueclass]
        ],
        ax: tuple = (),
        overwrite: bool = False,
        **kwargs,
    ):
        &#34;&#34;&#34;Adds metadata to the plot. This is done by adding a text box to the plot.

        Args:
            metadata (dict): The metadata to add to the plot. This is a dictionary with the keys as the metadata name and the values as the metadata value.
            ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
            overwrite (bool, optional): If True, the metadata is overwritten. If False, the metadata is added to the existing metadata. Defaults to False.
        &#34;&#34;&#34;
        if ax:
            self.ax = self.axs[ax]

        default_kwargs = {
            &#34;x&#34;: 0.05,
            &#34;y&#34;: 0.95,
            &#34;va&#34;: &#34;top&#34;,
            &#34;ha&#34;: &#34;left&#34;,
            &#34;transform&#34;: self.ax_anotate.transAxes,
            &#34;fontdict&#34;: {&#34;family&#34;: &#34;monospace&#34;},
        }
        kwargs = default_kwargs | kwargs
        algin = kwargs.pop(&#34;algin&#34;, True)

        kwargs_metadata = {
            k.removeprefix(&#34;tostr_&#34;): kwargs.pop(k)
            for k in list(kwargs)
            if k.startswith(&#34;tostr_&#34;)
        }
        metadata_str = self._convert_metadata_to_str(
            *metadata, algin=algin, **kwargs_metadata
        )
        self.metadata = metadata_str if overwrite else f&#34;{self.metadata}{metadata_str}&#34;

        self.ax_anotate.texts.clear()
        self.ax_anotate.text(s=self.metadata, **kwargs)
        self._remove_ax_anotate = False

    def _convert_metadata_to_str(
        self,
        *metadata: Union[
            str, Valueclass, list[Valueclass], tuple[Valueclass], dict[str, Valueclass]
        ],
        algin: bool = True,
        add_parameter_header: bool = True,
        **kwargs,
    ) -&gt; str:
        name_width = kwargs.pop(&#34;tostr_name_width&#34;, 40)
        size_width = kwargs.pop(&#34;tostr_size_width&#34;, 7)

        # parameter_header = f&#34;{Mesuerment parameters : &lt;{name_width}}&#34; TODO: add parameter header
        # {&#34;N points&#34; : &lt;{size_width}}Values&#34;

        metadata_str = &#34;&#34;
        for param in metadata:
            if isinstance(param, str):
                metadata_str += f&#34;{param}\n&#34;

            elif isinstance(param, Valueclass):
                metadata_str += f&#34;{param.tostr(algin=algin, name_width=name_width, size_width=size_width, **kwargs)}\n&#34;

            elif isinstance(param, (list, tuple)):
                for par in param:
                    metadata_str += self._convert_metadata_to_str(par)

            elif isinstance(param, dict):
                for par in param.values():
                    metadata_str += self._convert_metadata_to_str(par)

            else:
                raise TypeError(
                    f&#34;metadata must be of type str, Valueclass, list[Value], tuple[Value], or dict[str, Value], not {type(param)}&#34;
                )

        return metadata_str

    def clear_metadata(self):
        self.metadata = &#34;&#34;
        self.ax_anotate.texts.clear()

    def _get_default_transform(self):
        axarg = np.where(self.axs == self.ax)[0][0]
        right_axs = self.axs[axarg, np.size(self.axs, axis=1) - 1]

        return (
            right_axs.colorbar.ax.transAxes
            if hasattr(right_axs, &#34;colorbar&#34;)
            else self.ax.transAxes
        )

    def _label_with_unit_prefix(self, label: str, unit_prefix: str):
        return (
            label.replace(&#34;[&#34;, f&#34;[{unit_prefix}&#34;)
            if &#34;[&#34; in label and &#34;]&#34; in label
            else f&#34;{label} [{unit_prefix}]&#34;
            if unit_prefix
            else label
        )

    def _rescale_axes(self):
        for ax in self.axs.flatten():
            self._get_set_ticks(&#34;x&#34;)(self, ax)
            self._get_set_ticks(&#34;y&#34;)(self, ax)

            if hasattr(ax, &#34;colorbar&#34;):
                for colorbar in ax.colorbar:
                    self._get_set_ticks(&#34;y&#34;)(self, colorbar)
                    self._get_set_ticks(&#34;x&#34;)(self, colorbar)

        if hasattr(self, &#34;yres&#34;):
            self._get_set_ticks(&#34;x&#34;)(self, self.yres)

        if hasattr(self, &#34;xres&#34;):
            self._get_set_ticks(&#34;x&#34;)(self, self.xres)
            self._get_set_ticks(&#34;y&#34;)(self, self.xres)

    def _set_ticks(self, axis, ticks):
        _, unit_prefix, scale = convert_array_with_unit(ticks)
        ticks = ticker.FuncFormatter(lambda v, pos: &#34;{0:g}&#34;.format(v * scale))
        axis.set_major_formatter(ticks)
        return unit_prefix

    def _get_set_ticks(self, axis: str = &#34;x&#34;):
        if axis not in [&#34;x&#34;, &#34;y&#34;]:
            raise ValueError(f&#34;Unknown axis: {axis}&#34;)

        orig_label = f&#34;original_{axis}label&#34;
        get_ticks = f&#34;get_{axis}ticks&#34;
        get_label = f&#34;get_{axis}label&#34;

        def _set_ticks(self, ax):
            if not hasattr(ax, get_ticks):
                ax = ax.ax

            original_label = _get_original_label(ax)

            if any(x not in original_label for x in [&#34;[&#34;, &#34;]&#34;]):
                return

            ticks = getattr(ax, get_ticks)()
            unit_prefix = self._set_ticks(getattr(ax, f&#34;{axis}axis&#34;), ticks)

            updated_label = self._label_with_unit_prefix(original_label, unit_prefix)

            if axis == &#34;x&#34;:
                ax.set_xlabel(updated_label)
            else:
                ax.set_ylabel(updated_label)

        def _get_original_label(ax):
            if not hasattr(ax, orig_label):
                setattr(ax, orig_label, getattr(ax, get_label)())

            original_label = getattr(ax, orig_label)
            return original_label

        return _set_ticks

    def _plot_legends(self):
        &#34;&#34;&#34;Adds legends to the plot if the user has specified them.&#34;&#34;&#34;
        [
            ax.legend()
            for ax in self.axs.flatten()
            if ax.get_legend_handles_labels() != ([], [])
        ]

    def show(self, return_fig: bool = False):
        &#34;&#34;&#34;Shows the plot. This function is a wrapper for matplotlib.pyplot.show

        Returns:
            fig: The figure object
        &#34;&#34;&#34;
        plt.figure(self.fig)

        if self._remove_ax_anotate:
            self._remove_ax_anotate = False
            self.ax_anotate.remove()

        self._rescale_axes()
        plt.tight_layout()

        if not return_fig:
            return plt.show()

        for fig_num in plt.get_fignums():
            if self.fig.number != fig_num:  # type: ignore
                plt.close(fig_num)

        plt.pause(0.001)
        return self.fig

    def save(self, path: str, **kwargs):
        &#34;&#34;&#34;Saves the plot. This function is a wrapper for matplotlib.pyplot.savefig

        Args:
            path (str): The path to save the plot to.
        &#34;&#34;&#34;
        plt.savefig(path, **kwargs)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.add_metadata"><code class="name flex">
<span>def <span class="ident">add_metadata</span></span>(<span>self, *metadata: Union[str, <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>], tuple[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>], dict[str, <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>]], ax: tuple = (), overwrite: bool = False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Adds metadata to the plot. This is done by adding a text box to the plot.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>metadata</code></strong> :&ensp;<code>dict</code></dt>
<dd>The metadata to add to the plot. This is a dictionary with the keys as the metadata name and the values as the metadata value.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
<dt><strong><code>overwrite</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, the metadata is overwritten. If False, the metadata is added to the existing metadata. Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_metadata(
    self,
    *metadata: Union[
        str, Valueclass, list[Valueclass], tuple[Valueclass], dict[str, Valueclass]
    ],
    ax: tuple = (),
    overwrite: bool = False,
    **kwargs,
):
    &#34;&#34;&#34;Adds metadata to the plot. This is done by adding a text box to the plot.

    Args:
        metadata (dict): The metadata to add to the plot. This is a dictionary with the keys as the metadata name and the values as the metadata value.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
        overwrite (bool, optional): If True, the metadata is overwritten. If False, the metadata is added to the existing metadata. Defaults to False.
    &#34;&#34;&#34;
    if ax:
        self.ax = self.axs[ax]

    default_kwargs = {
        &#34;x&#34;: 0.05,
        &#34;y&#34;: 0.95,
        &#34;va&#34;: &#34;top&#34;,
        &#34;ha&#34;: &#34;left&#34;,
        &#34;transform&#34;: self.ax_anotate.transAxes,
        &#34;fontdict&#34;: {&#34;family&#34;: &#34;monospace&#34;},
    }
    kwargs = default_kwargs | kwargs
    algin = kwargs.pop(&#34;algin&#34;, True)

    kwargs_metadata = {
        k.removeprefix(&#34;tostr_&#34;): kwargs.pop(k)
        for k in list(kwargs)
        if k.startswith(&#34;tostr_&#34;)
    }
    metadata_str = self._convert_metadata_to_str(
        *metadata, algin=algin, **kwargs_metadata
    )
    self.metadata = metadata_str if overwrite else f&#34;{self.metadata}{metadata_str}&#34;

    self.ax_anotate.texts.clear()
    self.ax_anotate.text(s=self.metadata, **kwargs)
    self._remove_ax_anotate = False</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.add_xresiuals"><code class="name flex">
<span>def <span class="ident">add_xresiuals</span></span>(<span>self, x: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], y: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], z: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray, NoneType] = None, ax: tuple = (), *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for matplotlib functions to make them return a Valueclass object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The x data.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The y data.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>Valueclass</code>, optional</dt>
<dd>The z data. Defaults to None.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The axes to plot on. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(
    self,
    x: Union[Valueclass, list, tuple, np.ndarray],
    y: Union[Valueclass, list, tuple, np.ndarray],
    z: Optional[Union[Valueclass, list, tuple, np.ndarray]] = None,
    ax: tuple = (),
    *args,
    **kwargs,
):
    &#34;&#34;&#34;Wrapper for matplotlib functions to make them return a Valueclass object.

    Args:
        x (Valueclass): The x data.
        y (Valueclass): The y data.
        z (Valueclass, optional): The z data. Defaults to None.
        ax (tuple, optional): The axes to plot on. Defaults to ().
    &#34;&#34;&#34;
    x, y, z, kwargs = _matplotlib_general(self, x=x, y=y, z=z, ax=ax, **kwargs)

    if x is None or y is None:
        raise ValueError(&#34;x and y data must be specified.&#34;)

    if z:
        self.ax.grid(False)
        func(self, x=x, y=y, z=z, ax=ax, *args, **kwargs)
        _plot_legends(self)
        return

    func(self, x=x, y=y, ax=ax, *args, **kwargs)
    _plot_legends(self)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.add_yresiuals"><code class="name flex">
<span>def <span class="ident">add_yresiuals</span></span>(<span>self, x: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], y: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], z: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray, NoneType] = None, ax: tuple = (), *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for matplotlib functions to make them return a Valueclass object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The x data.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The y data.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>Valueclass</code>, optional</dt>
<dd>The z data. Defaults to None.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The axes to plot on. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(
    self,
    x: Union[Valueclass, list, tuple, np.ndarray],
    y: Union[Valueclass, list, tuple, np.ndarray],
    z: Optional[Union[Valueclass, list, tuple, np.ndarray]] = None,
    ax: tuple = (),
    *args,
    **kwargs,
):
    &#34;&#34;&#34;Wrapper for matplotlib functions to make them return a Valueclass object.

    Args:
        x (Valueclass): The x data.
        y (Valueclass): The y data.
        z (Valueclass, optional): The z data. Defaults to None.
        ax (tuple, optional): The axes to plot on. Defaults to ().
    &#34;&#34;&#34;
    x, y, z, kwargs = _matplotlib_general(self, x=x, y=y, z=z, ax=ax, **kwargs)

    if x is None or y is None:
        raise ValueError(&#34;x and y data must be specified.&#34;)

    if z:
        self.ax.grid(False)
        func(self, x=x, y=y, z=z, ax=ax, *args, **kwargs)
        _plot_legends(self)
        return

    func(self, x=x, y=y, ax=ax, *args, **kwargs)
    _plot_legends(self)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.axhline"><code class="name flex">
<span>def <span class="ident">axhline</span></span>(<span>self, y: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, tuple, list, float, numpy.ndarray], xmin: float = 0, xmax: float = 1, linestyle: str = '--', ax: tuple = (), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axhline</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>y</code></strong> :&ensp;<code>float</code></dt>
<dd>y value to plot.</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>float</code></dt>
<dd>minimum x value to plot.</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>float</code></dt>
<dd>maximum x value to plot.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def axhline(
    self,
    y: Union[Valueclass, tuple, list, float, np.ndarray],
    xmin: float = 0,
    xmax: float = 1,
    linestyle: str = &#34;--&#34;,
    ax: tuple = (),
    **kwargs,
):
    &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axhline

    Args:
        y (float): y value to plot.
        min (float): minimum x value to plot.
        max (float): maximum x value to plot.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
    &#34;&#34;&#34;
    if ax:
        self.ax = self.axs[ax]

    kwargs |= {&#34;xmin&#34;: xmin, &#34;xmax&#34;: xmax, &#34;linestyle&#34;: linestyle}

    if isinstance(y, Valueclass):
        self.ax.axhline(y=y.value, **kwargs)
    elif isinstance(y, (tuple, list)):
        for y_ in y:
            self.ax.axhline(y=y_, **kwargs)
    else:
        self.ax.axhline(y=y, **kwargs)

    self._plot_legends()</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.axvline"><code class="name flex">
<span>def <span class="ident">axvline</span></span>(<span>self, x: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, tuple, list, float, numpy.ndarray], ymin: float = 0, ymax: float = 1, linestyle: str = '--', ax: tuple = (), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axvline</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>float</code></dt>
<dd>x value to plot.</dd>
<dt><strong><code>min</code></strong> :&ensp;<code>float</code></dt>
<dd>minimum y value to plot.</dd>
<dt><strong><code>max</code></strong> :&ensp;<code>float</code></dt>
<dd>maximum y value to plot.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def axvline(
    self,
    x: Union[Valueclass, tuple, list, float, np.ndarray],
    ymin: float = 0,
    ymax: float = 1,
    linestyle: str = &#34;--&#34;,
    ax: tuple = (),
    **kwargs,
):
    &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.axvline

    Args:
        x (float): x value to plot.
        min (float): minimum y value to plot.
        max (float): maximum y value to plot.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
    &#34;&#34;&#34;
    if ax:
        self.ax = self.axs[ax]

    kwargs |= {&#34;ymin&#34;: ymin, &#34;ymax&#34;: ymax, &#34;linestyle&#34;: linestyle}

    if isinstance(x, Valueclass):
        self.ax.axvline(x=x.value, **kwargs)
    elif isinstance(x, (tuple, list)):
        for x_ in x:
            self.ax.axvline(x=x_, **kwargs)
    else:
        self.ax.axvline(x=x, **kwargs)

    self._plot_legends()</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.bar"><code class="name flex">
<span>def <span class="ident">bar</span></span>(<span>self, x: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], y: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], z: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray, NoneType] = None, ax: tuple = (), *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for matplotlib functions to make them return a Valueclass object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The x data.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The y data.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>Valueclass</code>, optional</dt>
<dd>The z data. Defaults to None.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The axes to plot on. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(
    self,
    x: Union[Valueclass, list, tuple, np.ndarray],
    y: Union[Valueclass, list, tuple, np.ndarray],
    z: Optional[Union[Valueclass, list, tuple, np.ndarray]] = None,
    ax: tuple = (),
    *args,
    **kwargs,
):
    &#34;&#34;&#34;Wrapper for matplotlib functions to make them return a Valueclass object.

    Args:
        x (Valueclass): The x data.
        y (Valueclass): The y data.
        z (Valueclass, optional): The z data. Defaults to None.
        ax (tuple, optional): The axes to plot on. Defaults to ().
    &#34;&#34;&#34;
    x, y, z, kwargs = _matplotlib_general(self, x=x, y=y, z=z, ax=ax, **kwargs)

    if x is None or y is None:
        raise ValueError(&#34;x and y data must be specified.&#34;)

    if z:
        self.ax.grid(False)
        func(self, x=x, y=y, z=z, ax=ax, *args, **kwargs)
        _plot_legends(self)
        return

    func(self, x=x, y=y, ax=ax, *args, **kwargs)
    _plot_legends(self)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.clear_metadata"><code class="name flex">
<span>def <span class="ident">clear_metadata</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_metadata(self):
    self.metadata = &#34;&#34;
    self.ax_anotate.texts.clear()</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.contour"><code class="name flex">
<span>def <span class="ident">contour</span></span>(<span>self, x: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, y: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, Z: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, ax: tuple = (), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.contour</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>x data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>y data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>z data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contour(
    self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
):
    &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.contour

    Args:
        x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
        y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
        Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
    &#34;&#34;&#34;
    self._2d_genereal_plot(plot_type=&#34;contour&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.contourf"><code class="name flex">
<span>def <span class="ident">contourf</span></span>(<span>self, x: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, y: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, Z: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, ax: tuple = (), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.contourf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>x data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>y data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>z data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contourf(
    self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
):
    &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.contourf

    Args:
        x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
        y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
        Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
    &#34;&#34;&#34;
    self._2d_genereal_plot(plot_type=&#34;contourf&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.errorbar"><code class="name flex">
<span>def <span class="ident">errorbar</span></span>(<span>self, x: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], y: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], z: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray, NoneType] = None, ax: tuple = (), *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for matplotlib functions to make them return a Valueclass object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The x data.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The y data.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>Valueclass</code>, optional</dt>
<dd>The z data. Defaults to None.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The axes to plot on. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(
    self,
    x: Union[Valueclass, list, tuple, np.ndarray],
    y: Union[Valueclass, list, tuple, np.ndarray],
    z: Optional[Union[Valueclass, list, tuple, np.ndarray]] = None,
    ax: tuple = (),
    *args,
    **kwargs,
):
    &#34;&#34;&#34;Wrapper for matplotlib functions to make them return a Valueclass object.

    Args:
        x (Valueclass): The x data.
        y (Valueclass): The y data.
        z (Valueclass, optional): The z data. Defaults to None.
        ax (tuple, optional): The axes to plot on. Defaults to ().
    &#34;&#34;&#34;
    x, y, z, kwargs = _matplotlib_general(self, x=x, y=y, z=z, ax=ax, **kwargs)

    if x is None or y is None:
        raise ValueError(&#34;x and y data must be specified.&#34;)

    if z:
        self.ax.grid(False)
        func(self, x=x, y=y, z=z, ax=ax, *args, **kwargs)
        _plot_legends(self)
        return

    func(self, x=x, y=y, ax=ax, *args, **kwargs)
    _plot_legends(self)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.heatmap"><code class="name flex">
<span>def <span class="ident">heatmap</span></span>(<span>self, x: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, y: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, Z: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, ax: tuple = (), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.pcolormesh</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>x data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>y data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>z data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def heatmap(
    self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
):
    &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.pcolormesh

    Args:
        x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
        y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
        Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
    &#34;&#34;&#34;
    self._2d_genereal_plot(plot_type=&#34;pcolormesh&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.pcolormesh"><code class="name flex">
<span>def <span class="ident">pcolormesh</span></span>(<span>self, x: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, y: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, Z: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, ax: tuple = (), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.pcolormesh</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>x data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>y data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>z data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def pcolormesh(
    self, x: Valueclass, y: Valueclass, Z: Valueclass, ax: tuple = (), **kwargs
):
    &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.pcolormesh

    Args:
        x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
        y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
        Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
    &#34;&#34;&#34;
    self._2d_genereal_plot(plot_type=&#34;pcolormesh&#34;, x=x, y=y, z=Z, ax=ax, **kwargs)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.plot"><code class="name flex">
<span>def <span class="ident">plot</span></span>(<span>self, x: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], y: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], z: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray, NoneType] = None, ax: tuple = (), *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for matplotlib functions to make them return a Valueclass object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The x data.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The y data.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>Valueclass</code>, optional</dt>
<dd>The z data. Defaults to None.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The axes to plot on. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(
    self,
    x: Union[Valueclass, list, tuple, np.ndarray],
    y: Union[Valueclass, list, tuple, np.ndarray],
    z: Optional[Union[Valueclass, list, tuple, np.ndarray]] = None,
    ax: tuple = (),
    *args,
    **kwargs,
):
    &#34;&#34;&#34;Wrapper for matplotlib functions to make them return a Valueclass object.

    Args:
        x (Valueclass): The x data.
        y (Valueclass): The y data.
        z (Valueclass, optional): The z data. Defaults to None.
        ax (tuple, optional): The axes to plot on. Defaults to ().
    &#34;&#34;&#34;
    x, y, z, kwargs = _matplotlib_general(self, x=x, y=y, z=z, ax=ax, **kwargs)

    if x is None or y is None:
        raise ValueError(&#34;x and y data must be specified.&#34;)

    if z:
        self.ax.grid(False)
        func(self, x=x, y=y, z=z, ax=ax, *args, **kwargs)
        _plot_legends(self)
        return

    func(self, x=x, y=y, ax=ax, *args, **kwargs)
    _plot_legends(self)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.plot_fit"><code class="name flex">
<span>def <span class="ident">plot_fit</span></span>(<span>self, fit_obejct: <a title="dataanalyzer.fitter.fitter_main.Fitter" href="../fitter/fitter_main.html#dataanalyzer.fitter.fitter_main.Fitter">Fitter</a>, ax: tuple = (), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Plots a fit object. This function is a wrapper for matplotlib.pyplot.plot</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fit_obejct</code></strong> :&ensp;<code>object</code></dt>
<dd>The fit object to plot.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_fit(self, fit_obejct: Fitter, ax: tuple = (), **kwargs):
    &#34;&#34;&#34;Plots a fit object. This function is a wrapper for matplotlib.pyplot.plot

    Args:
        fit_obejct (object): The fit object to plot.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
    &#34;&#34;&#34;
    flip_axis = kwargs.pop(&#34;flip_axis&#34;, False)
    ls_start = kwargs.pop(&#34;linspace_start&#34;, None)
    ls_stop = kwargs.pop(&#34;linspace_stop&#34;, None)
    ls_steps = kwargs.pop(&#34;linspace_steps&#34;, 1000)

    if kwargs.pop(&#34;force_fit&#34;, False) or not fit_obejct._fitted:
        fit_obejct.do_fit(**kwargs)

    if kwargs.pop(&#34;plot_data&#34;, True):
        x, y = fit_obejct.x, fit_obejct.y

        if flip_axis:
            x, y = y, x

        self.scatter(x, y, ax=ax, label=&#34;Data&#34;)

    if kwargs.pop(&#34;plot_guess&#34;, True):
        x_guess, y_guess = fit_obejct.get_guess_array(ls_start, ls_stop, ls_steps)
        x_guess = Valueclass.fromfloat(x_guess, &#34;X guess&#34;)
        y_guess = Valueclass.fromfloat(y_guess, &#34;Y guess&#34;)

        if flip_axis:
            x_guess, y_guess = y_guess, x_guess

        self.plot(x_guess, y_guess, ax=ax, ls=&#34;--&#34;, color=&#34;grey&#34;, label=&#34;Guess&#34;)

    if kwargs.pop(&#34;plot_fit&#34;, True):
        x_fit, y_fit = fit_obejct.get_fit_array(ls_start, ls_stop, ls_steps)
        x_fit = Valueclass.fromfloat(x_fit, &#34;X fitted&#34;)
        y_fit = Valueclass.fromfloat(y_fit, &#34;Y fitted&#34;)

        if flip_axis:
            x_fit, y_fit = y_fit, x_fit

        self.plot(x_fit, y_fit, ax=ax, label=&#34;Fit&#34;)

    if kwargs.pop(&#34;plot_residuals&#34;, False):
        x_res = fit_obejct.x
        y_res = fit_obejct.get_residuals()

        if flip_axis:
            x_res, y_res = y_res, x_res
            self.add_yresiuals(x_res, y_res, ax=ax)
        else:
            self.add_xresiuals(x_res, y_res, ax=ax)

    if kwargs.pop(&#34;plot_metadata&#34;, True):
        self.add_metadata(fit_obejct._report_string, ax=ax)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>self, path: str, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Saves the plot. This function is a wrapper for matplotlib.pyplot.savefig</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>path</code></strong> :&ensp;<code>str</code></dt>
<dd>The path to save the plot to.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save(self, path: str, **kwargs):
    &#34;&#34;&#34;Saves the plot. This function is a wrapper for matplotlib.pyplot.savefig

    Args:
        path (str): The path to save the plot to.
    &#34;&#34;&#34;
    plt.savefig(path, **kwargs)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.scatter"><code class="name flex">
<span>def <span class="ident">scatter</span></span>(<span>self, x: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], y: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray], z: Union[<a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, list, tuple, numpy.ndarray, NoneType] = None, ax: tuple = (), *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for matplotlib functions to make them return a Valueclass object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The x data.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>The y data.</dd>
<dt><strong><code>z</code></strong> :&ensp;<code>Valueclass</code>, optional</dt>
<dd>The z data. Defaults to None.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The axes to plot on. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def wrapper(
    self,
    x: Union[Valueclass, list, tuple, np.ndarray],
    y: Union[Valueclass, list, tuple, np.ndarray],
    z: Optional[Union[Valueclass, list, tuple, np.ndarray]] = None,
    ax: tuple = (),
    *args,
    **kwargs,
):
    &#34;&#34;&#34;Wrapper for matplotlib functions to make them return a Valueclass object.

    Args:
        x (Valueclass): The x data.
        y (Valueclass): The y data.
        z (Valueclass, optional): The z data. Defaults to None.
        ax (tuple, optional): The axes to plot on. Defaults to ().
    &#34;&#34;&#34;
    x, y, z, kwargs = _matplotlib_general(self, x=x, y=y, z=z, ax=ax, **kwargs)

    if x is None or y is None:
        raise ValueError(&#34;x and y data must be specified.&#34;)

    if z:
        self.ax.grid(False)
        func(self, x=x, y=y, z=z, ax=ax, *args, **kwargs)
        _plot_legends(self)
        return

    func(self, x=x, y=y, ax=ax, *args, **kwargs)
    _plot_legends(self)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.set_default_settings"><code class="name flex">
<span>def <span class="ident">set_default_settings</span></span>(<span>self, default_settings: Union[dict, str, bool] = True) ‑> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Sets the default settings for the plotter. This function is a wrapper for matplotlib.pyplot.style.use</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>default_settings</code></strong> :&ensp;<code>Union[dict, str, bool]</code>, optional</dt>
<dd>The default settings to use. Defaults to True.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_default_settings(
    self, default_settings: Union[dict, str, bool] = True
) -&gt; None:
    &#34;&#34;&#34;Sets the default settings for the plotter. This function is a wrapper for matplotlib.pyplot.style.use

    Args:
        default_settings (Union[dict, str, bool], optional): The default settings to use. Defaults to True.
    &#34;&#34;&#34;
    # If the user wants to use the default settings, load the default settings
    # from the quantum_calibrator.mplstyle file
    if default_settings is True or default_settings == &#34;quantum_calibrator&#34;:
        dirname = os.path.dirname(__file__)
        plt.style.use(
            os.path.join(dirname, r&#34;plot_styles/quantum_calibrator.mplstyle&#34;)
        )

    # If the user wants to use the presentation settings, load the presentation
    # settings from the presentation.mplstyle file
    elif default_settings == &#34;presentation&#34;:
        dirname = os.path.dirname(__file__)
        plt.style.use(os.path.join(dirname, r&#34;plot_styles/presentation.mplstyle&#34;))

    # If the user wants to use no default settings, load the default matplotlib
    # settings
    elif default_settings is False:
        plt.style.use(&#34;default&#34;)

    # If the user passes a dictionary with settings, load these settings
    elif isinstance(default_settings, dict):
        plt.rcParams.update(default_settings)

    # If the user passes a string with a style, load this style
    elif isinstance(default_settings, str):
        plt.style.use(default_settings)

    # If the user passes anything else, raise an error
    else:
        raise ValueError(
            &#34;default_settings must be either a dict, a string or a boolean&#34;
        )</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, return_fig: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Shows the plot. This function is a wrapper for matplotlib.pyplot.show</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>fig</code></dt>
<dd>The figure object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def show(self, return_fig: bool = False):
    &#34;&#34;&#34;Shows the plot. This function is a wrapper for matplotlib.pyplot.show

    Returns:
        fig: The figure object
    &#34;&#34;&#34;
    plt.figure(self.fig)

    if self._remove_ax_anotate:
        self._remove_ax_anotate = False
        self.ax_anotate.remove()

    self._rescale_axes()
    plt.tight_layout()

    if not return_fig:
        return plt.show()

    for fig_num in plt.get_fignums():
        if self.fig.number != fig_num:  # type: ignore
            plt.close(fig_num)

    plt.pause(0.001)
    return self.fig</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.tricontour"><code class="name flex">
<span>def <span class="ident">tricontour</span></span>(<span>self, x: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, y: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, z: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, ax: tuple = (), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tricontour</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>x data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>y data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>z data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tricontour(
    self, x: Valueclass, y: Valueclass, z: Valueclass, ax: tuple = (), **kwargs
):
    &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tricontour

    Args:
        x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
        y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
        Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
    &#34;&#34;&#34;
    self._2d_genereal_plot(plot_type=&#34;tricontour&#34;, x=x, y=y, z=z, ax=ax, **kwargs)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.tricontourf"><code class="name flex">
<span>def <span class="ident">tricontourf</span></span>(<span>self, x: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, y: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, z: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, ax: tuple = (), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tricontourf</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>x data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>y data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>z data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tricontourf(
    self, x: Valueclass, y: Valueclass, z: Valueclass, ax: tuple = (), **kwargs
):
    &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tricontourf

    Args:
        x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
        y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
        Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
    &#34;&#34;&#34;
    self._2d_genereal_plot(plot_type=&#34;tricontourf&#34;, x=x, y=y, z=z, ax=ax, **kwargs)</code></pre>
</details>
</dd>
<dt id="dataanalyzer.plotter.plotter_main.Plotter.tripcolor"><code class="name flex">
<span>def <span class="ident">tripcolor</span></span>(<span>self, x: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, y: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, z: <a title="dataanalyzer.utilities.valueclass.Valueclass" href="../utilities/valueclass.html#dataanalyzer.utilities.valueclass.Valueclass">Valueclass</a>, ax: tuple = (), **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tripcolor</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>x data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>y data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>Z</code></strong> :&ensp;<code>Valueclass</code></dt>
<dd>z data to plot. This data is converted to a Valueclass object if it is not already one.</dd>
<dt><strong><code>ax</code></strong> :&ensp;<code>tuple</code>, optional</dt>
<dd>The ax to use. If None, self._last_ax is used. Defaults to ().</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def tripcolor(
    self, x: Valueclass, y: Valueclass, z: Valueclass, ax: tuple = (), **kwargs
):
    &#34;&#34;&#34;plotting function for 2d data. This function is a wrapper for matplotlib.pyplot.tripcolor

    Args:
        x (Valueclass): x data to plot. This data is converted to a Valueclass object if it is not already one.
        y (Valueclass): y data to plot. This data is converted to a Valueclass object if it is not already one.
        Z (Valueclass): z data to plot. This data is converted to a Valueclass object if it is not already one.
        ax (tuple, optional): The ax to use. If None, self._last_ax is used. Defaults to ().
    &#34;&#34;&#34;
    self._2d_genereal_plot(plot_type=&#34;tripcolor&#34;, x=x, y=y, z=z, ax=ax, **kwargs)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dataanalyzer.plotter" href="index.html">dataanalyzer.plotter</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dataanalyzer.plotter.plotter_main.Plotter" href="#dataanalyzer.plotter.plotter_main.Plotter">Plotter</a></code></h4>
<ul class="">
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.add_metadata" href="#dataanalyzer.plotter.plotter_main.Plotter.add_metadata">add_metadata</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.add_xresiuals" href="#dataanalyzer.plotter.plotter_main.Plotter.add_xresiuals">add_xresiuals</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.add_yresiuals" href="#dataanalyzer.plotter.plotter_main.Plotter.add_yresiuals">add_yresiuals</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.axhline" href="#dataanalyzer.plotter.plotter_main.Plotter.axhline">axhline</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.axvline" href="#dataanalyzer.plotter.plotter_main.Plotter.axvline">axvline</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.bar" href="#dataanalyzer.plotter.plotter_main.Plotter.bar">bar</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.clear_metadata" href="#dataanalyzer.plotter.plotter_main.Plotter.clear_metadata">clear_metadata</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.contour" href="#dataanalyzer.plotter.plotter_main.Plotter.contour">contour</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.contourf" href="#dataanalyzer.plotter.plotter_main.Plotter.contourf">contourf</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.errorbar" href="#dataanalyzer.plotter.plotter_main.Plotter.errorbar">errorbar</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.heatmap" href="#dataanalyzer.plotter.plotter_main.Plotter.heatmap">heatmap</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.pcolormesh" href="#dataanalyzer.plotter.plotter_main.Plotter.pcolormesh">pcolormesh</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.plot" href="#dataanalyzer.plotter.plotter_main.Plotter.plot">plot</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.plot_fit" href="#dataanalyzer.plotter.plotter_main.Plotter.plot_fit">plot_fit</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.save" href="#dataanalyzer.plotter.plotter_main.Plotter.save">save</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.scatter" href="#dataanalyzer.plotter.plotter_main.Plotter.scatter">scatter</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.set_default_settings" href="#dataanalyzer.plotter.plotter_main.Plotter.set_default_settings">set_default_settings</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.show" href="#dataanalyzer.plotter.plotter_main.Plotter.show">show</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.tricontour" href="#dataanalyzer.plotter.plotter_main.Plotter.tricontour">tricontour</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.tricontourf" href="#dataanalyzer.plotter.plotter_main.Plotter.tricontourf">tricontourf</a></code></li>
<li><code><a title="dataanalyzer.plotter.plotter_main.Plotter.tripcolor" href="#dataanalyzer.plotter.plotter_main.Plotter.tripcolor">tripcolor</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>